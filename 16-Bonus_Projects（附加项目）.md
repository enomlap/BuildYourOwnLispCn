# 附加项目 • 第 16 章 

## 结束其实只是开始 
------
尽管我们这个 Lisp 相当强大，但距离完备的、具有生产力的编程语言还相差甚远。要想胜任实际项目绝对会遇到许多问题，还须要很多改进。解决这些问题才能使这个编程语言羽翼渐丰。 

以下是可能会遇到的一些问题以及这些问题的潜在解决方案，另附一些有关改进的趣味想法。有的几百行代码就能搞定，有的则可能需要几千行。解决哪些问题取决于你自己，如果喜欢，可能会乐于下面的一些项目。 

## 原生类型 

------

目前我们的语言只包装了原生 C 的`long`和 `char*`类型。  如果想做数值计算，这将是个很大的缺陷，我们对这些数据类型的运算也很有限。理想情况下，我们的语言应该包装所有 C 语言原生类型及相应的运算。最重要的功能之一便是小数的扩展，可将 `double`类型引入。对于各种数值类型，务必确保通用算术运算符例如 `+`和 `-`都能无差别操作。 

对于希望用他们的语言能够实现数值计算的人来说，添加对原生类型的支持都有必要。

## 用户定义类型 
------
除了原生类型，用户应该能够添加他们自己的类型，就像 C 语言的结构。至于如何实现将取决于你，扩展这些功能是语言走向成熟的必经之路。对于发明语言以及编程语言外观有自己想法的人来说，这个任务将会很有意思。 

## 列表文法
![列表](https://www.buildyourownlisp.com/static/img/list.png)

------

一些 lisp 使用方括号 `[]`的文法来表示求值列表。用这种语法糖可以将 `list 100 (+ 10 20) 300`写成 `[100 (+ 10 20) 300]`.这样方便多了，虽然占用了 `[]`导致不能再用于更有趣的事。 

如果希望添加额外语法，这应该是个简单的补充。

## 与操作系统互动
------
编辑语言步入实用阶段的很重要的标志就是能够操作文件。这须要包装所有C的文件操作函数，例如`fread`, `fwrite`, `fgetc`。这项工作并不复杂，但却相当繁重，因此当前并未有实现，留给你（译注：谁？）了。 类似的，还需要包装所有的系统调用。这样才能完成诸如改变目录、列出文件之类的工作。同样，难度不高，量却很大。对于任何实用的脚本语言而言这些都是必须的。如果希望自己的这个语言能够完成些简单的脚本任务并能操作字符串，肯定会对这些功能有兴趣。

## 宏Macros
------
许多其他Lisps实现允许你用`(def x 100)`来把`x`定义为`100`。我们这个语言却不行，因为它*首先*将试图在当前环境中对`x`求值。在Lisps中这类函数被称为*macros（宏）*。在*宏*里面，并不是先对参数求值，而是保持未求值状态。这个方法能够让一此复杂有趣的函数看起来和普通函数一样。

把这些加到这个语言肯定很有意思，好似*魔法*似的能够大量避免重复。 

我们实现了不使用`宏`的版本的 `def`和 `if`，如果您不太喜欢它当前的工作方式，而希望它更类似于传统的 Lisps，这可能是您有兴趣实现的东西。 

## 变量哈希表 
------
当前，当查找变量名时，只是对环境中的所有变量进行线性搜索。附着变量变多，这会越来越低效。另一个高效的方法是实现一个 *哈希表* 。 将变量名称转换为对应的整数索引，并使用它来索引到一个已知大小的数组，迅速查询到与此符号关联的值。这种数据结构极其重要并常见，在高负载下仍有出色性能。任何有兴趣了解更多数据结构与算法的聪明人肯定会想办法来实现这种数据结构或其某种变体。 

## 内存池分配 
------
我们的 Lisp 很虽然简陋，速度却很渣。其性能接近于一些脚本语言，如 Python 和 Ruby。很大一部分性能开销来自于大量用`malloc`构造和销毁 `lval`（译注：参考C语言和OS教程。此过程涉及到OS调用相当吃资源）。这是一个缓慢的函数，它需要操作系统为我们做一些管理。我们的代码中在执行时，有大量的`lval`类型复制、分配和销毁。 

如果想要减少这种开销，需要减少 `malloc`的调用。一个方法是在程序开始时调用 `malloc`一次性申请一片大一点的内存。之后所有 `malloc`调用都重写，调用我们自己的函数，将内存分片和切块以供程序使用。 这意味着我们正在以更快的本地方式模拟操作系统的一些行为。这称为*内存池分配*，在游戏开发和其他对性能敏感的应用中很常用。

这实现起来略难，不过还好，概念上并不难。这个技术很有助于快速提高性能。 

## 垃圾收集
------
几乎所有 Lisps 的其他实现都以与我们不同的方式分配变量。它们不在环境中存储值的副本，而是直接存储指向它的指针或引用，如同 C 语言中那样。由于使用的是指针而非副本，在应对大型数据结构时所需的开销要少得多。 

如果我们存储指向值的指针而不是副本，则需要确保在其他地方尝试访问它之前不会删除指向的数据。当没有任何引用时，我们希望将其销毁。执行此操作的一种方法称为 *Mark（标记）* 和 *Sweep（回收）* ，即监视环境中的值以及新分配的每个值。当一个变量被放入环境中时，它及其引用的所有内容都被打上 *标记* 。释放时，则需要遍历所有分配，删除其中不带标记的。 

这称为 *垃圾收集* ，是许多编程语言不可或缺的一部分。与内存池分配一样，实现 *垃圾收集* 器不很复杂，但需要格外谨慎，这能使语言更高效。实现这一点对于使这种语言适用于处理大量数据至关重要。在[此处(http://journal.stuffwithstuff.com/2013/12/08/babys-first-garbage-collector/)]能找到有关在 C 中实现垃圾收集器的特别好的教程 。 

这个技术能够提高语言性能，并更进变量在内在中存储和访问的方式。 

## 尾优化（译注：即*尾递归*）
------
我们的编程语言使用 *递归* 来进行循环。 这个方法理论上讲真是聪明绝顶，然而实际性能却很相当差（译注：参考编译原理，每次函数调用的成本非常高，涉及大量中断、寄存器操作）。递归函数调用自己来收集计算的所有部分结果，之后再将所有结果组合在一起。 如果其中部分结果可以在循环中累积为某个总数时，这是一种极其奢侈的计算方式。 对于很大的循环或无限循环，这是一个大问题。 

满足一定条件的递归函数可以转换为等效的 `while` 循环。 这种自动转换称为 *尾调用优化* ，对于使用递归进行大量循环的程序来说必不可少。 

对编译器优化和不同计算形式之间的转换感兴趣的人一定会觉得这件工作很有趣。 

## 词法范围 
------
当我们的语言试图查找一个未定义的变量时，它会抛出一个错误。 最好它可以在求值之前就提示哪些变量未定义。 这将使我们避免打字错误和其他一些恼人的崩溃。 在程序运行之前发现这些问题称为 *词法作用域* 检查，它使用变量定义规则，在求值之前就尝试推断在程序不同的位置哪些变量已定义，而哪些变量未定义。 

这可能是一项很难完全正确的任务，但对于想要使他们的编程语言使用更安全且不易出错的人来说应该很有趣。 


## 静态检查
![静止的](https://www.buildyourownlisp.com/static/img/static.png)

静电 • 令人毛骨悚然的替代品。 
------
程序中的每个值都有一个关联的类型，在进行求值之前类型就是已知的了。 当前内置函数也只接受某些类型作为输入。 我们应该能够使用这些信息来推断新的用户定义函数和值的类型。  我们还可以使用此信息来检查在运行程序之前是否使用了正确的类型调用函数。 这将有助于减少函数在求值时所报的类型错误。 这种检查称为 *静态检查* 。 

类型是计算机科学中一个非常有趣和基础的部分。  它们是目前我们所知道的在运行程序之前检测错误的最佳方法。  任何对编程语言安全和类型理论感兴趣的人都会发现这个项目非常有趣。 

## 结论 

------

非常感谢您阅读本文。  我希望你在这些文字中读到了一些你感兴趣的东西。  如果你喜欢它，请告诉你的朋友。  如果你打算继续开发你的语言，那么祝你好运，我希望你能学到更多关于 C、编程语言和计算机科学的知识。 

最重要的是，我希望您在构建自己的 Lisp 时玩得开心。  下将再见！ 

## （译注：这下真的再见了）。
